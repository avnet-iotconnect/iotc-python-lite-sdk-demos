// This file was autogenerated by SmartHLS on Nov 24 2025, 05:15:47

#pragma GCC diagnostic ignored "-Wpointer-arith"
#include "hls/hls_physmap.h"
#include "hls/hls_alloc.h"
#include <cstdlib>
#include <map>
#include <algorithm>
#include <vector>
#include "tinyml_complex_accelerator_driver.h"
#include <string.h>
#include <stdio.h>
#include <stdint.h>
#include <unistd.h>

#ifdef HLS_PROFILER_ENABLE
#include "hls/soc_profiler/soc_profiler.hpp"
#endif

#ifdef HLS_PROFILER_ENABLE
hls::soc_profiler<0x70100000, 1> hls_main_prof("main");
#endif


// ----- Accelerator base information
struct accelerator_base {
    uint32_t base_addr;
    int fd;
    void *virtmap;
};
    
#ifdef HLS_PROFILER_ENABLE
hls::soc_profiler<0x70100000, HLS_PROFILER_SAMPLES> tinyml_accel_prof("tinyml_accel");
#endif


#ifndef MAX_TINYML_ACCEL_ACCELERATORS
#define MAX_TINYML_ACCEL_ACCELERATORS    10
#endif

// ----- Zero initialized accelerator instances
static volatile accelerator_base tinyml_accel_instances[MAX_TINYML_ACCEL_ACCELERATORS] = {0};
static int tinyml_accel_num_instances = 0;


// ----- Mapping virtual to physical address for tinyml_accel accelerators
static uint32_t tinyml_accel_virtmap_to_phyaddr(void* virt_addr) {
    for (int i = 0; i < tinyml_accel_num_instances; i++){
        if (tinyml_accel_instances[i].virtmap == (uint32_t*)virt_addr)
            return tinyml_accel_instances[i].base_addr;
    }
    
    perror("Error: Instance not found\n");
    return 0;
}

void tinyml_accel_teardown() {
    for (int i = 0; i < tinyml_accel_num_instances; i++) {
        if (unmap_physical(tinyml_accel_instances[i].virtmap, TINYML_ACCEL_SPAN_ADDR) == -1)
            perror("tinyml_accel_teardown() error: couldn't close virtual to physical "
            "memory map for accelerator.");

        if (close_physical(tinyml_accel_instances[i].fd) == -1)
            perror("tinyml_accel_teardown() error: couldn't close physical memory file "
            "descriptor.");
    }
    tinyml_accel_num_instances = 0;
}

void tinyml_accel_teardown(void* virt_addr) {
    for (int i = 0; i < tinyml_accel_num_instances; i++) {
        if((char *)tinyml_accel_instances[i].virtmap == (char*)virt_addr) {
            if (unmap_physical(tinyml_accel_instances[i].virtmap, TINYML_ACCEL_SPAN_ADDR) == -1)
                perror("tinyml_accel_teardown() error: couldn't close virtual to physical "
                "memory map for accelerator.");

            if (close_physical(tinyml_accel_instances[i].fd) == -1)
                perror("tinyml_accel_teardown() error: couldn't close physical memory file "
                "descriptor.");
        }
        tinyml_accel_num_instances -= 1;
        return;
    }
}

void* tinyml_accel_setup(uint32_t base_addr) {

    // ----- Check if the instance already exists
    for (int i = 0; i < tinyml_accel_num_instances; i++){
        if (tinyml_accel_instances[i].base_addr == base_addr)
            return tinyml_accel_instances[i].virtmap;
    }

    // ----- Check if we have exceeded the maximum number of instances
    if (tinyml_accel_num_instances >= MAX_TINYML_ACCEL_ACCELERATORS){
        perror("Error: Exceeded maximum number of tinyml_accel accelerator "
        "instances\n");
        return NULL;
    }
       
    // ----- Open physical memory as a file descriptor
    int fd = open_physical(-1);
    if (fd == -1) {
        perror("Error: Couldn't open physical memory file descriptor.");
        tinyml_accel_teardown();
        return NULL;
    }

    // ----- Create virtual to physical memory map for accelerator
    void *virtmap = map_physical(fd, base_addr, TINYML_ACCEL_SPAN_ADDR);
    if (virtmap == NULL) {
        perror("Error: Couldn't create virtual to physical memory map for "
        "accelerator.");
        tinyml_accel_teardown();
        return NULL;
    }

    // ----- Add instance to the list
    tinyml_accel_instances[tinyml_accel_num_instances].base_addr = base_addr;
    tinyml_accel_instances[tinyml_accel_num_instances].fd = fd;
    tinyml_accel_instances[tinyml_accel_num_instances].virtmap = virtmap;

    tinyml_accel_num_instances++;

    // ----- Register teardown function to run on program exit
    if (tinyml_accel_num_instances == 1)
        std::atexit(tinyml_accel_teardown);
    
    return virtmap;
}

template <class Tp>
inline __attribute__((always_inline)) void DoNotOptimize(Tp const& value) {
       __asm("fence.i");
}


void tinyml_accel_memcpy_write_in(void* in, uint64_t byte_size, void *virt_addr) {

    void* in_ptr = memcpy((char*)virt_addr + 0x40, in, byte_size);
    DoNotOptimize(in_ptr);
}

void tinyml_accel_memcpy_read_in(void* in, uint64_t byte_size, void *virt_addr) {

    memcpy(in, (char*)virt_addr + 0x40, byte_size);
}

void tinyml_accel_dma_write_in(void* in, uint64_t byte_size, void *virt_addr){

    // Use DMA to copy input arguments from processor to accelerator.
    uint32_t base_addr = tinyml_accel_virtmap_to_phyaddr(virt_addr);
    hls_memcpy((void*)(uintptr_t)(base_addr + 0x40), (void*)(in), byte_size, HLS_ALLOC_MSS_TO_FPGA, HLS_ALLOC_PDMA);

}

void tinyml_accel_dma_read_in(void* in, uint64_t byte_size, void *virt_addr){

    // Use DMA to copy output arguments from accelerator to processor.
    uint32_t base_addr = tinyml_accel_virtmap_to_phyaddr(virt_addr);
    hls_memcpy((void*)(in), (void*)(uintptr_t)(base_addr + 0x40), byte_size, HLS_ALLOC_FPGA_TO_MSS, HLS_ALLOC_PDMA);

}

void tinyml_accel_memcpy_write_out(void* out, uint64_t byte_size, void *virt_addr) {

    void* out_ptr = memcpy((char*)virt_addr + 0x80040, out, byte_size);
    DoNotOptimize(out_ptr);
}

void tinyml_accel_memcpy_read_out(void* out, uint64_t byte_size, void *virt_addr) {

    memcpy(out, (char*)virt_addr + 0x80040, byte_size);
}

void tinyml_accel_dma_write_out(void* out, uint64_t byte_size, void *virt_addr){

    // Use DMA to copy input arguments from processor to accelerator.
    uint32_t base_addr = tinyml_accel_virtmap_to_phyaddr(virt_addr);
    hls_memcpy((void*)(uintptr_t)(base_addr + 0x80040), (void*)(out), byte_size, HLS_ALLOC_MSS_TO_FPGA, HLS_ALLOC_PDMA);

}

void tinyml_accel_dma_read_out(void* out, uint64_t byte_size, void *virt_addr){

    // Use DMA to copy output arguments from accelerator to processor.
    uint32_t base_addr = tinyml_accel_virtmap_to_phyaddr(virt_addr);
    hls_memcpy((void*)(out), (void*)(uintptr_t)(base_addr + 0x80040), byte_size, HLS_ALLOC_FPGA_TO_MSS, HLS_ALLOC_PDMA);

}

void tinyml_accel_write_batch_n(uint32_t val,  void *virt_addr) {

    *(volatile uint32_t *)((char*)virt_addr + 0xc) = (volatile uint32_t) val;
}

uint32_t tinyml_accel_read_batch_n(void *virt_addr) {

    return *(volatile uint32_t *)((char *)virt_addr + 0xc);
}

int tinyml_accel_is_idle(void *virt_addr) {

    volatile int *acc_start_addr =
        (volatile int *)((char*)virt_addr + 8); // base+8

    return *acc_start_addr == 0;
}

// This is a non-blocking function that starts the computation on the accelerator.
// Any arguments, if any, should be written using the write functions given.
// Use tinyml_accel_join_and_read_output() to wait for the accelerator to finish and return with the result.
void tinyml_accel_start(void *virt_addr) {
#ifdef HLS_PROFILER_ENABLE
    // Add the "start" event to the profiler
    tinyml_accel_prof.timestamp_start();
#endif

    // Run accelerator
    volatile int *acc_start_addr =
        (volatile int *)((char*)virt_addr + 8); // base+8

    *acc_start_addr = 1;
}

// This is a blocking function that waits for the computation started by tinyml_accel_start() to return.
// The return value is the result computed by the accelerator.
void tinyml_accel_join(void *virt_addr) {

    // Wait for accelerator to finish, acc_start_addr is set to 1 in the start function
    while (!tinyml_accel_is_idle(virt_addr)) {}
#ifdef HLS_PROFILER_ENABLE
    // Add the "join" event to the profiler
    tinyml_accel_prof.timestamp_join();
#endif

}


// This is a blocking function that calls and waits for the accelerator to return.
// The return value is the result computed by the accelerator.
void tinyml_accel_hls_driver(void* in, void* out, uint32_t batch_n, uint32_t base_addr) {

    // Run setup function
    void *virt_addr = tinyml_accel_setup(base_addr);
    if (virt_addr == NULL) {
        printf("Error: setup function failed for tinyml_accel");
        exit(EXIT_FAILURE);
    }

    tinyml_accel_write_input_and_start(in, batch_n, virt_addr);
    tinyml_accel_join_and_read_output(out, virt_addr);
    tinyml_accel_teardown(virt_addr);
}


// This is a non-blocking function that starts the computation on the accelerator.
// Use tinyml_accel_join() to wait for the accelerator to finish and return with the result.
void tinyml_accel_write_input_and_start(void* in, uint32_t batch_n, void *virt_addr) {

#ifdef HLS_PROFILER_ENABLE
    // Add the "wr_begin" event to the profiler
    tinyml_accel_prof.timestamp_wr_begin();
#endif

    tinyml_accel_dma_write_in(in, 524288, (char*)virt_addr);
    tinyml_accel_write_batch_n(batch_n, virt_addr);

    tinyml_accel_start(virt_addr);

}


// This is a blocking function that waits for the computation started by tinyml_accel_start() to return.
// The return value is the result computed by the accelerator.
void tinyml_accel_join_and_read_output(void* out, void *virt_addr) {

    tinyml_accel_join(virt_addr);

    tinyml_accel_dma_read_out(out, 24576, (char*)virt_addr);
#ifdef HLS_PROFILER_ENABLE
    // Add the "rd_end" event to the profiler
    tinyml_accel_prof.timestamp_rd_end();
#endif

}


